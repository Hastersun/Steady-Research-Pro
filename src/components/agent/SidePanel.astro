<aside class="w-full lg:w-80 flex-shrink-0 space-y-6" id="side-panel" data-i18n-scope="sidePanel">
  <div class="glass-card rounded-2xl border border-white/12 px-5 py-6 text-slate-200">
    <h2 class="text-sm font-semibold tracking-[0.28em] text-slate-300 uppercase" data-i18n="sidePanel.title">AI ç ”ç©¶é…ç½®</h2>
    <form class="mt-4 space-y-4" id="config-form">
      <div>
        <label class="block text-xs font-medium text-slate-300 mb-1" data-i18n="sidePanel.topicLabel">ç ”ç©¶ä¸»é¢˜</label>
        <input id="research-topic" type="text" class="w-full rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2.5 text-sm text-slate-100 placeholder:text-slate-500 focus:border-brand-300 focus:ring-2 focus:ring-brand-400/60" data-i18n-attrPlaceholder="sidePanel.topicPlaceholder" placeholder="ä¾‹å¦‚ï¼šå¤§è¯­è¨€æ¨¡å‹åœ¨æ•™è‚²é¢†åŸŸçš„åº”ç”¨" />
      </div>
      <div>
        <label class="block text-xs font-medium text-slate-300 mb-1" data-i18n="sidePanel.modelLabel">é€‰æ‹© AI æ¨¡å‹</label>
        <select id="research-model" class="w-full rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2.5 text-sm text-slate-100 focus:border-brand-300 focus:ring-2 focus:ring-brand-400/60">
          <option value="" data-i18n="sidePanel.modelLoading">åŠ è½½ä¸­...</option>
        </select>
        <p id="provider-hint" class="mt-1 text-[11px] text-slate-400" data-i18n="sidePanel.modelConfigHint">ä½¿ç”¨ Settings é¡µé¢çš„å½“å‰æœåŠ¡é…ç½®</p>
      </div>
      <div>
        <label class="block text-xs font-medium text-slate-300 mb-1" data-i18n="sidePanel.depthLabel">æ·±åº¦çº§åˆ«</label>
        <select id="depth-level" class="w-full rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2.5 text-sm text-slate-100 focus:border-brand-300 focus:ring-2 focus:ring-brand-400/60">
          <option value="basic" data-i18n="sidePanel.depthBasic">åŸºç¡€åˆ†æ</option>
          <option value="standard" selected data-i18n="sidePanel.depthStandard">æ ‡å‡†ç ”ç©¶</option>
          <option value="deep" data-i18n="sidePanel.depthDeep">æ·±åº¦ç ”ç©¶</option>
        </select>
      </div>
      <div>
        <label class="block text-xs font-medium text-slate-300 mb-1" data-i18n="sidePanel.focusLabel">ç ”ç©¶é‡ç‚¹</label>
        <textarea id="research-focus" rows="2" class="w-full rounded-xl border border-white/10 bg-slate-900/60 px-3 py-2.5 text-sm text-slate-100 placeholder:text-slate-500 focus:border-brand-300 focus:ring-2 focus:ring-brand-400/60" data-i18n-attrPlaceholder="sidePanel.focusPlaceholder" placeholder="æè¿°ç‰¹å®šçš„ç ”ç©¶è§’åº¦æˆ–å…³æ³¨ç‚¹..."></textarea>
            <li class="before:content-[''] before:absolute before:-start-4 before:top-1.5 before:w-2 before:h-2 before:rounded-full before:${statusClass} relative" data-step="${step.id}">
      <div class="flex items-center justify-between pt-2">
        <button type="button" id="stop-btn" class="items-center gap-1.5 rounded-full bg-red-500/90 px-3.5 py-2 text-xs font-semibold text-white shadow hover:bg-red-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500/70 hidden" data-i18n="sidePanel.stop">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/><path stroke-linecap="round" stroke-linejoin="round" d="M9 10h6v4H9z"/></svg>
          åœæ­¢
        </button>
        <button id="start-btn" type="submit" class="inline-flex items-center gap-1.5 rounded-full bg-gradient-to-r from-emerald-400/85 via-brand-400/80 to-sky-500/75 px-4 py-2 text-xs font-semibold text-slate-900 shadow hover:from-emerald-300 hover:to-sky-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-emerald-400/60" data-i18n="sidePanel.start">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
          å¼€å§‹ AI ç ”ç©¶
        </button>
      </div>
    </form>
  </div>
  <div class="glass-card glass-card--muted rounded-2xl border border-white/12 px-5 py-6" id="progress-card">
    <h3 class="text-sm font-semibold tracking-[0.28em] text-slate-300 uppercase mb-4" data-i18n="sidePanel.progressTitle">è¿›åº¦</h3>
    <div class="mb-4">
      <div class="h-1.5 w-full overflow-hidden rounded-full border border-white/10 bg-white/10 relative">
        <div id="progress-bar" class="h-full w-0 bg-gradient-to-r from-brand-300 via-brand-400 to-sky-400 transition-all duration-500 ease-out"></div>
        <div class="absolute inset-0 bg-[linear-gradient(110deg,rgba(255,255,255,0)_0%,rgba(255,255,255,.6)_40%,rgba(255,255,255,0)_70%)] animate-shimmer pointer-events-none mix-blend-overlay"></div>
      </div>
      <div id="progress-meta" class="mt-1 text-[10px] font-medium tracking-wide text-slate-300/80 select-none" data-i18n="sidePanel.progressIdle">0% Â· ç­‰å¾…å¼€å§‹</div>
    </div>
    <ol id="progress-timeline" class="relative ms-4 space-y-5 text-slate-200/85" aria-live="polite"></ol>
  </div>
</aside>

<script>
  // @ts-nocheck
  let isResearching = false;
  let currentStream = null;
  let providerState = { provider: 'manual', config: null, models: [] };
  let syncRetryTimer = null;

  const STORAGE_KEY = 'steady-research-pro:search-config';
  const AI_SERVICE_STORAGE_KEY = 'steady-research-pro:ai-service';

  const researchTopic = document.getElementById('research-topic');
  const researchModel = document.getElementById('research-model');
  const depthLevel = document.getElementById('depth-level');
  const researchFocus = document.getElementById('research-focus');
  const startBtn = document.getElementById('start-btn');
  const stopBtn = document.getElementById('stop-btn');
  const progressBar = document.getElementById('progress-bar');
  const progressMeta = document.getElementById('progress-meta');
  const progressTimeline = document.getElementById('progress-timeline');
  const configForm = document.getElementById('config-form');
  const providerHint = document.getElementById('provider-hint');

  const i18n = (window).__steadyI18n || {};
  const translate = (key, params, fallback) => {
    if (i18n && typeof i18n.t === 'function') {
      try {
        return i18n.t(key, params);
      } catch (error) {
        console.warn('[i18n] translate error', error);
      }
    }
    return fallback ?? key;
  };

  const LEGACY_STEPS = [
    { id: 'plan', stepType: 'plan', key: 'sidePanel.stepPlan', fallback: 'ç”Ÿæˆç ”ç©¶è®¡åˆ’', icon: 'ğŸ“‹' },
    { id: 'search', stepType: 'search', key: 'sidePanel.stepSearch', fallback: 'å¤šæºæœç´¢', icon: 'ğŸ”' },
    { id: 'extract', stepType: 'extract', key: 'sidePanel.stepExtract', fallback: 'å†…å®¹æå–', icon: 'ğŸ“„' },
    { id: 'cluster', stepType: 'cluster', key: 'sidePanel.stepCluster', fallback: 'ä¸»é¢˜èšç±»', icon: 'ğŸ”—' },
    { id: 'synthesis', stepType: 'synthesis', key: 'sidePanel.stepSynthesis', fallback: 'ç»¼åˆåˆ†æ', icon: 'ğŸ§ ' }
  ];

  const DEEP_STEPS = [
    { id: 'plan', stepType: 'plan', key: 'sidePanel.stepPlan', fallback: 'ç”Ÿæˆç ”ç©¶è®¡åˆ’', icon: 'ğŸ“‹' },
    { id: 'search', stepType: 'deep_search', key: 'sidePanel.stepDeepSearch', fallback: 'å¤šæºæ·±åº¦æœç´¢', icon: 'ğŸ”' },
    { id: 'cluster', stepType: 'modeling', key: 'sidePanel.stepModeling', fallback: 'ç»“æ„åŒ–å»ºæ¨¡', icon: 'ğŸ§©' },
    { id: 'synthesis', stepType: 'reporting', key: 'sidePanel.stepReporting', fallback: 'æ™ºèƒ½æŠ¥å‘Šç”Ÿæˆ', icon: 'ğŸ“' }
  ];

  let currentSteps = [...LEGACY_STEPS];
  const stepStatuses = new Map();

  const researchState = {
    mode: 'legacy',
    deepAgent: null,
    search: null,
    providerDeepAgent: {}
  };

  function getSelectorInstance() {
    if (typeof window === 'undefined') return null;
    const globalAny = window;
    return typeof globalAny.getAIServiceSelector === 'function' ? globalAny.getAIServiceSelector() : null;
  }

  function scheduleSyncRetry() {
    if (typeof window === 'undefined') return;
    if (syncRetryTimer) {
      window.clearTimeout(syncRetryTimer);
    }
    syncRetryTimer = window.setTimeout(() => {
      syncRetryTimer = null;
      syncProviderState();
    }, 400);
  }

  function syncProviderState(detail) {
    let provider = 'manual';
    let config = null;
    let models = [];

    if (detail?.provider) {
      provider = detail.provider;
      config = detail.config || null;
      if (Array.isArray(detail.models)) {
        models = [...detail.models];
      } else if (Array.isArray(detail.config?.models)) {
        models = [...detail.config.models];
      }
    } else {
      const selector = getSelectorInstance();
      if (selector?.getCurrentProvider) {
        const state = selector.getCurrentProvider();
        if (state) {
          provider = state.provider;
          config = state.config || null;
          if (Array.isArray(state.models)) {
            models = [...state.models];
          } else if (Array.isArray(state.config?.models)) {
            models = [...state.config.models];
          }
        }
      }
    }

    if (!config) {
      providerState = { provider, config: null, models: [] };
      updateModelOptions();
      updateProviderHint();
      if (!detail) {
        scheduleSyncRetry();
      }
      return;
    }

    if (syncRetryTimer) {
      window.clearTimeout(syncRetryTimer);
      syncRetryTimer = null;
    }

    providerState = { provider, config, models };

    const mappingSource = detail?.deepAgent || config?.deepAgent;
    if (mappingSource) {
      researchState.providerDeepAgent = {
        ...(researchState.providerDeepAgent || {}),
        [provider]: { ...mappingSource }
      };
      if (typeof window !== 'undefined') {
        window.steadyResearchConfig = window.steadyResearchConfig || {};
        window.steadyResearchConfig.providerDeepAgent = {
          ...(window.steadyResearchConfig.providerDeepAgent || {}),
          [provider]: { ...mappingSource }
        };
      }
    }

    updateModelOptions();
    updateProviderHint();
  }

  function updateModelOptions() {
    const select = researchModel;
    if (!select) return;

    const models = Array.isArray(providerState.models) ? providerState.models : [];
    const fallbackModel = providerState.config?.model;

    select.innerHTML = '';

    if (models.length > 0) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = translate('sidePanel.modelPlaceholder', {}, 'è¯·é€‰æ‹©æ¨¡å‹');
      select.appendChild(placeholder);

      models.forEach((model) => {
        const option = document.createElement('option');
        option.value = model;
        option.textContent = model;
        select.appendChild(option);
      });

      if (fallbackModel && models.includes(fallbackModel)) {
        select.value = fallbackModel;
      }
    } else if (fallbackModel) {
      const option = document.createElement('option');
      option.value = fallbackModel;
      option.textContent = fallbackModel;
      select.appendChild(option);
      select.value = fallbackModel;
    } else {
      const option = document.createElement('option');
      option.value = '';
      option.textContent = translate('sidePanel.providerMissing', {}, 'è¯·åœ¨ Settings é¡µé¢é…ç½®æ¨¡å‹');
      select.appendChild(option);
      select.value = '';
    }

    select.disabled = models.length === 0 && !fallbackModel;
    if (i18n && typeof i18n.applyTranslations === 'function') {
      i18n.applyTranslations(select);
    }
  }

  function updateProviderHint() {
    if (providerHint) {
      if (!providerState.config) {
        providerHint.textContent = translate('sidePanel.providerMissing', {}, 'å½“å‰æ²¡æœ‰é…ç½® AI æœåŠ¡ï¼Œè¯·å…ˆå‰å¾€ Settings è®¾ç½®ã€‚');
        providerHint.classList.remove('text-slate-400', 'text-emerald-300', 'text-amber-300', 'text-rose-400');
        providerHint.classList.add('text-rose-400');
      } else {
        const { name, available, model } = providerState.config;
        const statusKey = available ? 'sidePanel.providerStatusConnected' : 'sidePanel.providerStatusDisconnected';
        const statusText = translate(statusKey, {}, available ? 'å·²è¿æ¥' : 'æœªè¿æ¥');
        const modelText = model ? translate('sidePanel.providerStatusModelSuffix', { model }, ` Â· æ¨¡å‹ï¼š${model}`) : '';
        providerHint.textContent = translate('sidePanel.providerStatus', {
          name: name || providerState.provider,
          status: statusText,
          model: modelText
        }, `å½“å‰æœåŠ¡ï¼š${name || providerState.provider} Â· çŠ¶æ€ï¼š${statusText}${modelText}`);
        providerHint.classList.remove('text-slate-400', 'text-emerald-300', 'text-amber-300', 'text-rose-400');
        providerHint.classList.add(available ? 'text-emerald-300' : 'text-amber-300');
      }
    }

    if (startBtn) {
      if (isResearching) {
        startBtn.disabled = true;
      } else {
        const disabled = !providerState.config || !providerState.config.available;
        startBtn.disabled = disabled;
        startBtn.classList.toggle('opacity-50', disabled);
        startBtn.classList.toggle('cursor-not-allowed', disabled);
      }
    }
  }

  function readStoredSearchConfig() {
    if (typeof window === 'undefined' || !window.localStorage) return null;
    try {
      const raw = window.localStorage.getItem(STORAGE_KEY);
      return raw ? JSON.parse(raw) : null;
    } catch (error) {
      console.warn('[search-config] failed to read storage', error);
      return null;
    }
  }

  function readStoredAIServiceConfig() {
    if (typeof window === 'undefined' || !window.localStorage) return null;
    try {
      const raw = window.localStorage.getItem(AI_SERVICE_STORAGE_KEY);
      return raw ? JSON.parse(raw) : null;
    } catch (error) {
      console.warn('[ai-service] failed to read storage', error);
      return null;
    }
  }

  function extractProviderDeepAgent(config) {
    if (!config?.providers) return {};
    const mapping = {};
    Object.entries(config.providers).forEach(([provider, value]) => {
      if (value?.deepAgent) {
        mapping[provider] = { ...value.deepAgent };
      }
    });
    return mapping;
  }

  function getDeepAgentConfig() {
    if (typeof window !== 'undefined' && window.steadyResearchConfig?.deepAgent) {
      return window.steadyResearchConfig.deepAgent;
    }
    const stored = readStoredSearchConfig();
    return stored?.deepAgent || null;
  }

  function getProviderDeepAgent() {
    if (typeof window !== 'undefined' && window.steadyResearchConfig?.providerDeepAgent) {
      return { ...window.steadyResearchConfig.providerDeepAgent };
    }
    const stored = readStoredAIServiceConfig();
    return extractProviderDeepAgent(stored || {});
  }

  function getSearchConfig() {
    if (typeof window !== 'undefined' && window.steadyResearchConfig?.search) {
      return window.steadyResearchConfig.search;
    }
    const stored = readStoredSearchConfig();
    if (!stored) return null;
    return {
      engines: Array.isArray(stored.engines) ? stored.engines : [],
      bing: stored.bing || '',
      google: stored.google || '',
      googleCseId: stored.googleCseId || ''
    };
  }

  function syncResearchConfig() {
    researchState.deepAgent = getDeepAgentConfig();
    researchState.search = getSearchConfig();
    researchState.providerDeepAgent = getProviderDeepAgent();
  }

  function buildSearchOptions(config) {
    if (!config) return null;
    const engines = Array.isArray(config.engines) ? config.engines.filter(Boolean) : [];
    const apiKeys = {
      bing: config.bing || '',
      google: config.google || '',
      googleCseId: config.googleCseId || ''
    };

    const hasKeys = apiKeys.bing || (apiKeys.google && apiKeys.googleCseId);
    if (!engines.length && !hasKeys) return null;

    return {
      engines: engines.length ? engines : undefined,
      apiKeys
    };
  }

  function buildDeepAgentOptions(config) {
    if (!config?.enabled) return { enabled: false };
    return {
      enabled: true,
      models: config.models || {},
      sampling: config.sampling || {},
      engines: config.engines || undefined,
      engineOptions: config.engineOptions || undefined,
      maxResults: typeof config.maxResults === 'number' ? config.maxResults : undefined,
      maxQueries: typeof config.maxQueries === 'number' ? config.maxQueries : undefined
    };
  }

  function setCurrentSteps(mode) {
    researchState.mode = mode === 'deep' ? 'deep' : 'legacy';
    currentSteps = researchState.mode === 'deep' ? DEEP_STEPS : LEGACY_STEPS;
    stepStatuses.clear();
    renderTimeline();
  }

  function renderTimeline(activeStepId = null) {
    if (!progressTimeline) return;

    progressTimeline.innerHTML = currentSteps.map((step) => {
      const status = stepStatuses.get(step.id) || 'pending';
      let indicatorClass = 'bg-white/15';
      let textClass = 'text-slate-500';
      let statusText = translate('sidePanel.stepPending', {}, 'ç­‰å¾…æ‰§è¡Œ');

      if (status === 'done') {
        indicatorClass = 'bg-emerald-300';
        textClass = 'text-slate-200';
        statusText = translate('sidePanel.stepComplete', {}, 'âœ“ å®Œæˆ');
      } else if (status === 'active' || (activeStepId && step.id === activeStepId && status !== 'done')) {
        indicatorClass = 'bg-brand-300 animate-pulse';
        textClass = 'text-white';
        statusText = translate('sidePanel.stepRunning', {}, 'ğŸ”„ è¿›è¡Œä¸­');
      } else if (status === 'error') {
        indicatorClass = 'bg-rose-400 animate-pulse';
        textClass = 'text-rose-200';
        statusText = translate('sidePanel.stepError', {}, 'âš ï¸ å‡ºé”™');
      }

      const labelText = translate(step.key, {}, step.fallback);
      return `
        <li class="before:content-[''] before:absolute before:-start-4 before:top-1.5 before:w-2 before:h-2 before:rounded-full before:${indicatorClass} relative" data-step="${step.id}">
          <div class="flex items-center gap-2">
            <span class="text-sm">${step.icon}</span>
            <p class="text-xs font-medium ${textClass}">${labelText}</p>
          </div>
          <p class="text-[10px] text-slate-400 mt-0.5">${statusText}</p>
        </li>
      `;
    }).join('');
  }

  function setStepStatus(stepId, status) {
    if (!stepId) return;
    stepStatuses.set(stepId, status);
  }

  function resolveMessage(update) {
    if (!update) return '';
    if (update.messageKey) {
      try {
        return translate(update.messageKey, update.messageParams || {}, update.message || update.messageKey);
      } catch (error) {
        console.warn('[research] translate message failed', error);
      }
    }
    return update.message || '';
  }

  function updateProgress(progress, message) {
    if (progressBar && Number.isFinite(progress)) {
      const clamped = Math.max(0, Math.min(100, progress));
      progressBar.style.width = `${clamped}%`;
    }
    if (progressMeta) {
      const text = message || translate('sidePanel.progressIdle', {}, '0% Â· ç­‰å¾…å¼€å§‹');
      const prefix = Number.isFinite(progress) ? `${Math.round(Math.max(0, Math.min(100, progress)))}% Â· ` : '';
      progressMeta.textContent = `${prefix}${text}`.trim();
    }
  }

  function resetProgress() {
    if (progressBar) progressBar.style.width = '0%';
    if (progressMeta) {
      progressMeta.textContent = translate('sidePanel.progressIdle', {}, '0% Â· ç­‰å¾…å¼€å§‹');
    }
  }

  function updateReasoningPanel(data) {
    const event = new CustomEvent('research-update', {
      detail: data
    });
    document.dispatchEvent(event);
  }

  function updateUIForResearchState() {
    if (startBtn && stopBtn) {
      if (isResearching) {
        startBtn.classList.add('hidden');
        stopBtn.classList.remove('hidden');
        stopBtn.classList.add('inline-flex');
      } else {
        startBtn.classList.remove('hidden');
        stopBtn.classList.add('hidden');
        stopBtn.classList.remove('inline-flex');
      }
    }
    updateProviderHint();
  }

  function getSelectedModel() {
    const selectedModel = researchModel?.value;
    const fallbackModel = providerState.config?.model;
    return selectedModel || fallbackModel;
  }

  async function startResearch() {
    const topic = researchTopic?.value?.trim();
    const model = getSelectedModel();
    const focus = researchFocus?.value?.trim();
    const depth = depthLevel?.value || 'standard';

    if (!topic) {
      alert(translate('sidePanel.validationTopic', {}, 'è¯·è¾“å…¥ç ”ç©¶ä¸»é¢˜'));
      return;
    }

    if (!providerState.config) {
      alert(translate('sidePanel.validationProvider', {}, 'è¯·å…ˆåœ¨ Settings é¡µé¢é…ç½® AI æœåŠ¡'));
      return;
    }

    if (!model) {
      alert(translate('sidePanel.validationModel', {}, 'è¯·é€‰æ‹©æˆ–é…ç½® AI æ¨¡å‹'));
      return;
    }

    if (!providerState.config.available) {
      alert(translate('sidePanel.validationOffline', {}, 'å½“å‰ AI æœåŠ¡æœªè¿æ¥ï¼Œè¯·å…ˆåœ¨ Settings é¡µé¢æµ‹è¯•è¿æ¥'));
      return;
    }

    syncResearchConfig();
    const searchOptions = buildSearchOptions(researchState.search);
    const providerMapping = (researchState.providerDeepAgent || {})[providerState.provider] || {};
    const deepAgentBase = buildDeepAgentOptions(researchState.deepAgent);
    const deepEnabled = Boolean(deepAgentBase?.enabled);
    const baseModels = {
      search: providerMapping.search || model,
      modeling: providerMapping.modeling || model,
      report: providerMapping.report || model
    };
    const combinedDeepAgent = deepEnabled
      ? {
          ...deepAgentBase,
          models: {
            search: deepAgentBase.models?.search || baseModels.search,
            modeling: deepAgentBase.models?.modeling || baseModels.modeling,
            report: deepAgentBase.models?.report || baseModels.report
          },
          providerMapping: {
            ...providerMapping,
            enabled: Boolean(providerMapping?.enabled)
          }
        }
      : null;
    const mode = deepEnabled ? 'deep' : 'legacy';

    setCurrentSteps(mode);
    isResearching = true;
    updateUIForResearchState();
    resetProgress();

    document.dispatchEvent(new CustomEvent('research:start', {
      detail: {
        mode,
        query: topic,
        provider: providerState.provider,
        model,
        deepAgentEnabled: deepEnabled
      }
    }));

    const options = {
      depth,
      temperature: 0.7,
      focus
    };

    if (searchOptions) {
      options.search = searchOptions;
    }
    if (deepEnabled && combinedDeepAgent) {
      options.deepAgent = combinedDeepAgent;
    }

    try {
      const response = await fetch('/api/research-stream', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: topic,
          model,
          provider: providerState.provider,
          options
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      currentStream = reader;

      if (!reader) {
        throw new Error('æ— æ³•è·å–å“åº”æµ');
      }

      const lastStep = currentSteps[currentSteps.length - 1];
      let hasCompleted = false;
      let buffer = '';

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        let newlineIndex;

        while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
          const line = buffer.slice(0, newlineIndex).trim();
          buffer = buffer.slice(newlineIndex + 1);

          if (!line.startsWith('data: ')) continue;
          const jsonStr = line.slice(6).trim();
          if (!jsonStr) continue;

          let update;
          try {
            update = JSON.parse(jsonStr);
          } catch (error) {
            console.warn('JSON è§£æé”™è¯¯ï¼Œè·³è¿‡è¯¥è¡Œ:', jsonStr);
            continue;
          }

          if (update.done) {
            hasCompleted = true;
            continue;
          }

          if (!update.stepId) {
            continue;
          }

          const payload = typeof update.data === 'string' ? { raw: update.data } : (update.data || {});
          const stepType = payload.stepType || update.stepId;
          const timelineStep = currentSteps.find((step) => step.stepType === stepType || step.id === update.stepId);

          if (timelineStep) {
            if (update.status === 'start') {
              setStepStatus(timelineStep.id, 'active');
            } else if (update.status === 'progress') {
              setStepStatus(timelineStep.id, 'active');
            } else if (update.status === 'complete') {
              setStepStatus(timelineStep.id, 'done');
              if (timelineStep.id === lastStep?.id) {
                hasCompleted = true;
              }
            } else if (update.status === 'error') {
              setStepStatus(timelineStep.id, 'error');
            }
            renderTimeline(timelineStep.id);
          }

          const message = resolveMessage(update);
          updateProgress(update.progress, message);

          updateReasoningPanel({
            ...update,
            data: payload,
            mode: researchState.mode
          });
        }
      }

      if (hasCompleted) {
        completeResearch();
      } else if (isResearching) {
        stopResearch();
      }
    } catch (error) {
      console.error('ç ”ç©¶è¿‡ç¨‹å¤±è´¥:', error);
      alert(translate('sidePanel.researchFailed', { message: error.message }, `ç ”ç©¶å¤±è´¥: ${error.message}`));
      document.dispatchEvent(new CustomEvent('research:error', { detail: { message: error.message } }));
      stopResearch();
    }
  }

  function stopResearch() {
    if (!isResearching) {
      if (currentStream) {
        try {
          currentStream.cancel?.();
        } catch (e) {
          console.log('Stream already closed');
        }
        currentStream = null;
      }
      return;
    }

    isResearching = false;

    if (currentStream) {
      try {
        currentStream.cancel?.();
      } catch (e) {
        console.log('Stream already closed');
      }
      currentStream = null;
    }

    updateUIForResearchState();
    stepStatuses.clear();
    renderTimeline();
    updateProgress(0, translate('sidePanel.progressStopped', {}, 'å·²åœæ­¢'));
    document.dispatchEvent(new CustomEvent('research:stop', {
      detail: { mode: researchState.mode }
    }));
    setTimeout(() => resetProgress(), 1500);
  }

  function completeResearch() {
    if (!isResearching) return;
    isResearching = false;
    updateUIForResearchState();
    const finalStep = currentSteps[currentSteps.length - 1];
    if (finalStep) {
      setStepStatus(finalStep.id, 'done');
      renderTimeline(finalStep.id);
    }
    updateProgress(100, translate('sidePanel.progressCompleted', {}, 'ç ”ç©¶å®Œæˆ'));
    document.dispatchEvent(new CustomEvent('research:complete', {
      detail: { mode: researchState.mode }
    }));
    setTimeout(() => {
      stepStatuses.clear();
      renderTimeline();
      resetProgress();
    }, 3000);
  }

  function initResearchPanel() {
    setupEventListeners();
    syncProviderState();
    syncResearchConfig();
    setCurrentSteps(researchState.deepAgent?.enabled ? 'deep' : 'legacy');
    renderTimeline();
    if (i18n && typeof i18n.applyTranslations === 'function') {
      i18n.applyTranslations(document.getElementById('side-panel'));
    }
  }

  function setupEventListeners() {
    configForm?.addEventListener('submit', async (e) => {
      e.preventDefault();
      await startResearch();
    });

    stopBtn?.addEventListener('click', () => {
      stopResearch();
    });

    window.addEventListener('aiProviderChanged', (event) => {
      const detail = event instanceof CustomEvent ? event.detail : undefined;
      syncProviderState(detail);
    });

    window.addEventListener('deepAgent:configChanged', (event) => {
      researchState.deepAgent = event.detail || null;
      setCurrentSteps(researchState.deepAgent?.enabled ? 'deep' : 'legacy');
    });

    window.addEventListener('searchConfig:updated', (event) => {
      researchState.search = event.detail || researchState.search;
    });

    window.addEventListener('deepAgent:providerMapping', (event) => {
      const mapping = event instanceof CustomEvent ? event.detail : undefined;
      if (mapping && typeof mapping === 'object') {
        researchState.providerDeepAgent = mapping;
      }
    });
  }

  if (i18n && typeof i18n.onLocaleChange === 'function') {
    i18n.onLocaleChange(() => {
      renderTimeline();
      updateProviderHint();
      updateModelOptions();
      if (!isResearching && progressMeta) {
        progressMeta.textContent = translate('sidePanel.progressIdle', {}, '0% Â· ç­‰å¾…å¼€å§‹');
      }
    });
  }

  document.addEventListener('DOMContentLoaded', initResearchPanel);
  document.addEventListener('astro:page-load', () => {
    syncProviderState();
    syncResearchConfig();
    setCurrentSteps(researchState.deepAgent?.enabled ? 'deep' : 'legacy');
  });
</script>