<aside class="w-full lg:w-72 flex-shrink-0 space-y-6" id="side-panel">
  <div class="bg-white/70 backdrop-blur rounded-xl shadow-soft border border-gray-100 p-5">
    <h2 class="text-sm font-semibold tracking-wide text-gray-500 uppercase">AI ç ”ç©¶é…ç½®</h2>
    <form class="mt-4 space-y-4" id="config-form">
      <div>
        <label class="block text-xs font-medium text-gray-600 mb-1">ç ”ç©¶ä¸»é¢˜</label>
        <input id="research-topic" type="text" placeholder="ä¾‹å¦‚ï¼šå¤§è¯­è¨€æ¨¡å‹åœ¨æ•™è‚²é¢†åŸŸçš„åº”ç”¨" class="w-full rounded-md border-gray-300 focus:border-brand-500 focus:ring-brand-500 text-sm" />
      </div>
      <div>
        <label class="block text-xs font-medium text-gray-600 mb-1">é€‰æ‹© AI æ¨¡å‹</label>
        <select id="research-model" class="w-full rounded-md border-gray-300 focus:border-brand-500 focus:ring-brand-500 text-sm">
          <option value="">åŠ è½½ä¸­...</option>
        </select>
        <p id="provider-hint" class="mt-1 text-[11px] text-gray-500">ä½¿ç”¨ Settings é¡µé¢çš„å½“å‰æœåŠ¡é…ç½®</p>
      </div>
      <div>
        <label class="block text-xs font-medium text-gray-600 mb-1">æ·±åº¦çº§åˆ«</label>
        <select id="depth-level" class="w-full rounded-md border-gray-300 focus:border-brand-500 focus:ring-brand-500 text-sm">
          <option value="basic">åŸºç¡€åˆ†æ</option>
          <option value="standard" selected>æ ‡å‡†ç ”ç©¶</option>
          <option value="deep">æ·±åº¦ç ”ç©¶</option>
        </select>
      </div>
      <div>
        <label class="block text-xs font-medium text-gray-600 mb-1">ç ”ç©¶é‡ç‚¹</label>
        <textarea id="research-focus" rows="2" placeholder="æè¿°ç‰¹å®šçš„ç ”ç©¶è§’åº¦æˆ–å…³æ³¨ç‚¹..." class="w-full rounded-md border-gray-300 focus:border-brand-500 focus:ring-brand-500 text-sm"></textarea>
      </div>
      <div class="flex items-center justify-between pt-2">
        <button type="button" id="stop-btn" class="items-center gap-1.5 rounded-md bg-red-600 px-3 py-2 text-xs font-medium text-white shadow hover:bg-red-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 hidden">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/><path stroke-linecap="round" stroke-linejoin="round" d="M9 10h6v4H9z"/></svg>
          åœæ­¢
        </button>
        <button id="start-btn" type="submit" class="inline-flex items-center gap-1.5 rounded-md bg-gray-900 px-3 py-2 text-xs font-medium text-white shadow hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-900">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
          å¼€å§‹ AI ç ”ç©¶
        </button>
      </div>
    </form>
  </div>
  <div class="bg-white/70 backdrop-blur rounded-xl shadow-soft border border-gray-100 p-5" id="progress-card">
    <h3 class="text-sm font-semibold tracking-wide text-gray-500 uppercase mb-3">è¿›åº¦</h3>
    <div class="mb-4">
      <div class="h-1.5 w-full bg-gray-200 rounded overflow-hidden relative">
        <div id="progress-bar" class="h-full w-0 bg-gradient-to-r from-brand-400 via-brand-500 to-brand-600 transition-all duration-500 ease-out"></div>
        <div class="absolute inset-0 bg-[linear-gradient(110deg,rgba(255,255,255,0)_0%,rgba(255,255,255,.6)_40%,rgba(255,255,255,0)_70%)] animate-shimmer pointer-events-none mix-blend-overlay"></div>
      </div>
      <div id="progress-meta" class="mt-1 text-[10px] font-medium tracking-wide text-gray-500 select-none">0% Â· ç­‰å¾…å¼€å§‹</div>
    </div>
    <ol id="progress-timeline" class="relative ms-4 space-y-5" aria-live="polite"></ol>
  </div>
</aside>

<script>
  // @ts-nocheck
  // AI ç ”ç©¶åŠŸèƒ½é›†æˆ
  let isResearching = false;
  let currentStream = null;
  let providerState = { provider: 'manual', config: null, models: [] };
  let syncRetryTimer = null;

  // å…ƒç´ å¼•ç”¨
  const researchTopic = document.getElementById('research-topic');
  const researchModel = document.getElementById('research-model');
  const depthLevel = document.getElementById('depth-level');
  const researchFocus = document.getElementById('research-focus');
  const startBtn = document.getElementById('start-btn');
  const stopBtn = document.getElementById('stop-btn');
  const progressBar = document.getElementById('progress-bar');
  const progressMeta = document.getElementById('progress-meta');
  const progressTimeline = document.getElementById('progress-timeline');
  const configForm = document.getElementById('config-form');
  const providerHint = document.getElementById('provider-hint');

  // ç ”ç©¶æ­¥éª¤é…ç½®
  const researchSteps = [
    { id: 'plan', label: 'ç”Ÿæˆç ”ç©¶è®¡åˆ’', icon: 'ğŸ“‹' },
    { id: 'search', label: 'å¤šæºæœç´¢', icon: 'ğŸ”' },
    { id: 'extract', label: 'å†…å®¹æå–', icon: 'ğŸ“„' },
    { id: 'cluster', label: 'ä¸»é¢˜èšç±»', icon: 'ğŸ”—' },
    { id: 'synthesis', label: 'ç»¼åˆåˆ†æ', icon: 'ğŸ§ ' }
  ];

  function getSelectorInstance() {
    if (typeof window === 'undefined') return null;
    const globalAny = window as any;
    return typeof globalAny.getAIServiceSelector === 'function' ? globalAny.getAIServiceSelector() : null;
  }

  function scheduleSyncRetry() {
    if (typeof window === 'undefined') return;
    if (syncRetryTimer) {
      window.clearTimeout(syncRetryTimer);
    }
    syncRetryTimer = window.setTimeout(() => {
      syncRetryTimer = null;
      syncProviderState();
    }, 400);
  }

  function syncProviderState(detail) {
    let provider = 'manual';
    let config = null;
    let models = [];

    if (detail?.provider) {
      provider = detail.provider;
      config = detail.config || null;
      if (Array.isArray(detail.models)) {
        models = [...detail.models];
      } else if (Array.isArray(detail.config?.models)) {
        models = [...detail.config.models];
      }
    } else {
      const selector = getSelectorInstance();
      if (selector?.getCurrentProvider) {
        const state = selector.getCurrentProvider();
        if (state) {
          provider = state.provider;
          config = state.config || null;
          if (Array.isArray(state.models)) {
            models = [...state.models];
          } else if (Array.isArray(state.config?.models)) {
            models = [...state.config.models];
          }
        }
      }
    }

    if (!config) {
      providerState = { provider, config: null, models: [] };
      updateModelOptions();
      updateProviderHint();
      if (!detail) {
        scheduleSyncRetry();
      }
      return;
    }

    if (syncRetryTimer) {
      window.clearTimeout(syncRetryTimer);
      syncRetryTimer = null;
    }

    providerState = { provider, config, models };
    updateModelOptions();
    updateProviderHint();
  }

  function updateModelOptions() {
  const select = researchModel;
    if (!select) return;

    const models = Array.isArray(providerState.models) ? providerState.models : [];
    const fallbackModel = providerState.config?.model;

    select.innerHTML = '';

    if (models.length > 0) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'è¯·é€‰æ‹©æ¨¡å‹';
      select.appendChild(placeholder);

      models.forEach((model) => {
        const option = document.createElement('option');
        option.value = model;
        option.textContent = model;
        select.appendChild(option);
      });

      if (fallbackModel && models.includes(fallbackModel)) {
        select.value = fallbackModel;
      }
    } else if (fallbackModel) {
      const option = document.createElement('option');
      option.value = fallbackModel;
      option.textContent = fallbackModel;
      select.appendChild(option);
      select.value = fallbackModel;
    } else {
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'è¯·åœ¨ Settings é¡µé¢é…ç½®æ¨¡å‹';
      select.appendChild(option);
      select.value = '';
    }

    select.disabled = models.length === 0 && !fallbackModel;
  }

  function updateProviderHint() {
    if (providerHint) {
      if (!providerState.config) {
        providerHint.textContent = 'å½“å‰æ²¡æœ‰é…ç½® AI æœåŠ¡ï¼Œè¯·å…ˆå‰å¾€ Settings è®¾ç½®ã€‚';
        providerHint.classList.remove('text-gray-500');
        providerHint.classList.add('text-red-500');
      } else {
  const { name, available, model } = providerState.config;
        const statusText = available ? 'å·²è¿æ¥' : 'æœªè¿æ¥';
        const modelText = model ? ` Â· æ¨¡å‹ï¼š${model}` : '';
        providerHint.textContent = `å½“å‰æœåŠ¡ï¼š${name || providerState.provider} Â· çŠ¶æ€ï¼š${statusText}${modelText}`;
        providerHint.classList.remove('text-red-500', 'text-gray-500');
        providerHint.classList.add(available ? 'text-gray-500' : 'text-red-500');
      }
    }

    if (startBtn) {
      if (isResearching) {
        startBtn.disabled = true;
      } else {
        const disabled = !providerState.config || !providerState.config.available;
        startBtn.disabled = disabled;
        startBtn.classList.toggle('opacity-50', disabled);
        startBtn.classList.toggle('cursor-not-allowed', disabled);
      }
    }
  }

  // åˆå§‹åŒ–
  function initResearchPanel() {
    setupEventListeners();
    renderTimeline();
    syncProviderState();
  }

  // è®¾ç½®äº‹ä»¶ç›‘å¬
  function setupEventListeners() {
    // è¡¨å•æäº¤
    configForm?.addEventListener('submit', async (e) => {
      e.preventDefault();
      await startResearch();
    });

    // åœæ­¢æŒ‰é’®
    stopBtn?.addEventListener('click', () => {
      stopResearch();
    });

    window.addEventListener('aiProviderChanged', (event) => {
      const detail = event instanceof CustomEvent ? event.detail : undefined;
      syncProviderState(detail);
    });
  }

  // æ¸²æŸ“è¿›åº¦æ—¶é—´çº¿
  function renderTimeline(activeStep = null) {
    if (!progressTimeline) return;

    progressTimeline.innerHTML = researchSteps.map((step, index) => {
      const isActive = activeStep === step.id;
      const isCompleted = activeStep && researchSteps.findIndex(s => s.id === activeStep) > index;
      
      let statusClass = 'bg-gray-300';
      let textClass = 'text-gray-500';
      let status = '';

      if (isCompleted) {
        statusClass = 'bg-green-500';
        textClass = 'text-gray-900';
        status = 'âœ“ å®Œæˆ';
      } else if (isActive) {
        statusClass = 'bg-brand-500 animate-pulse';
        textClass = 'text-gray-900';
        status = 'ğŸ”„ è¿›è¡Œä¸­';
      }

      return `
        <li class="before:content-[''] before:absolute before:-start-4 before:top-1.5 before:w-2 before:h-2 before:rounded-full before:${statusClass} relative" data-step="${step.id}">
          <div class="flex items-center gap-2">
            <span class="text-sm">${step.icon}</span>
            <p class="text-xs font-medium ${textClass}">${step.label}</p>
          </div>
          <p class="text-[10px] text-gray-400 mt-0.5">${status}</p>
        </li>
      `;
    }).join('');
  }

  // æ›´æ–°è¿›åº¦
  function updateProgress(progress, message) {
    if (progressBar) {
      progressBar.style.width = `${progress}%`;
    }
    if (progressMeta) {
      progressMeta.textContent = `${progress}% Â· ${message}`;
    }
  }

  // å¼€å§‹ç ”ç©¶
  async function startResearch() {
    const topic = (researchTopic as HTMLInputElement)?.value?.trim();
    const selectedModel = (researchModel as HTMLSelectElement)?.value;
    const fallbackModel = providerState.config?.model;
    const model = selectedModel || fallbackModel;
    
    if (!topic) {
      alert('è¯·è¾“å…¥ç ”ç©¶ä¸»é¢˜');
      return;
    }
    
    if (!providerState.config) {
      alert('è¯·å…ˆåœ¨ Settings é¡µé¢é…ç½® AI æœåŠ¡');
      return;
    }

    if (!model) {
      alert('è¯·é€‰æ‹©æˆ–é…ç½® AI æ¨¡å‹');
      return;
    }

    if (!providerState.config.available) {
      alert('å½“å‰ AI æœåŠ¡æœªè¿æ¥ï¼Œè¯·å…ˆåœ¨ Settings é¡µé¢æµ‹è¯•è¿æ¥');
      return;
    }

    isResearching = true;
    updateUIForResearchState();
    
    // è§¦å‘ç ”ç©¶å¼€å§‹äº‹ä»¶ï¼Œè®© ResearchAgentUI å¼€å§‹åŠ¨ç”»
    document.dispatchEvent(new CustomEvent('research:start'));

    const options = {
      depth: (depthLevel as HTMLSelectElement)?.value || 'standard',
      temperature: 0.7, // å›ºå®šæ¸©åº¦å€¼
      focus: (researchFocus as HTMLTextAreaElement)?.value?.trim()
    };

    try {
      const response = await fetch('/api/research-stream', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: topic,
          model: model,
          provider: providerState.provider,
          options: options
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      currentStream = reader as any;

      if (!reader) {
        throw new Error('æ— æ³•è·å–å“åº”æµ');
      }

      while (true) {
        const { value, done } = await reader.read();
        
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const jsonStr = line.slice(6).trim();
            if (!jsonStr) continue; // è·³è¿‡ç©ºè¡Œ
            
            try {
              const data = JSON.parse(jsonStr);
              
              if (data.error) {
                throw new Error(data.message || 'ç ”ç©¶è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯');
              }
              
              if (data.done) {
                completeResearch();
                return;
              }
              
              // æ›´æ–°è¿›åº¦å’Œæ—¶é—´çº¿
              if (data.stepId && data.progress !== undefined) {
                updateProgress(data.progress, data.message);
                renderTimeline(data.stepId);
                
                // æ›´æ–°æ¨ç†é¢æ¿å’Œæœç´¢æ—¥å¿—
                if (data.data) {
                  updateReasoningPanel(data);
                }
              }
            } catch (e) {
              if (e instanceof SyntaxError) {
                console.warn('JSON è§£æé”™è¯¯ï¼Œè·³è¿‡è¯¥è¡Œ:', jsonStr);
                continue;
              }
              throw e;
            }
          }
        }
      }
    } catch (error) {
      console.error('ç ”ç©¶è¿‡ç¨‹å¤±è´¥:', error);
      alert(`ç ”ç©¶å¤±è´¥: ${error.message}`);
      stopResearch();
    }
  }

  // åœæ­¢ç ”ç©¶
  function stopResearch() {
    isResearching = false;
    
    if (currentStream) {
      try {
        (currentStream as any).cancel?.();
      } catch (e) {
        console.log('Stream already closed');
      }
      currentStream = null;
    }
    
    updateUIForResearchState();
    updateProgress(0, 'å·²åœæ­¢');
    renderTimeline();
  }

  // å®Œæˆç ”ç©¶
  function completeResearch() {
    isResearching = false;
    updateUIForResearchState();
    updateProgress(100, 'ç ”ç©¶å®Œæˆ');
    
    // æ˜¾ç¤ºå®ŒæˆçŠ¶æ€
    setTimeout(() => {
      updateProgress(0, 'ç­‰å¾…å¼€å§‹');
      renderTimeline();
    }, 3000);
  }

  // æ›´æ–°UIçŠ¶æ€
  function updateUIForResearchState() {
    if (startBtn && stopBtn) {
      if (isResearching) {
        startBtn.classList.add('hidden');
        stopBtn.classList.remove('hidden');
        stopBtn.classList.add('inline-flex');
      } else {
        startBtn.classList.remove('hidden');
        stopBtn.classList.add('hidden');
        stopBtn.classList.remove('inline-flex');
      }
    }
    updateProviderHint();
  }

  // æ›´æ–°æ¨ç†é¢æ¿ï¼ˆä¸ä¸»ç•Œé¢çš„æ¨ç†é¢æ¿äº¤äº’ï¼‰
  function updateReasoningPanel(data) {
    // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶ï¼Œè®©ä¸»ç•Œé¢å¤„ç†
    const event = new CustomEvent('research-update', {
      detail: data
    });
    document.dispatchEvent(event);
  }

  // å¯åŠ¨åˆå§‹åŒ–
  document.addEventListener('DOMContentLoaded', initResearchPanel);
  document.addEventListener('astro:page-load', () => syncProviderState());
</script>